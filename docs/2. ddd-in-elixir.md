# DDD in Elixir: Aggregates, Repositories & Entities

I'll create a comprehensive guide showing how to implement DDD's core building blocks in Elixir, with practical examples.I've created a comprehensive guide showing how to implement DDD concepts in Elixir with complete working examples.

**Key takeaways:**

1. **Entities** - Use structs with unique IDs, equality based on identity
2. **Value Objects** - Immutable structs compared by value, enforce validation
3. **Aggregates** - Cluster of entities with one root that enforces invariants through functions
4. **Repositories** - Only for aggregate roots, use behaviours for interfaces

**Important differences in Elixir:**

- **Immutability** - You return new versions of aggregates, not mutate them
- **Pattern matching** - Use it to enforce valid state transitions
- **Behaviours** - Replace interfaces for dependency injection
- **Separate schemas** - Keep Ecto schemas separate from domain entities
- **Pure functions** - All business logic should be testable pure functions

**Common patterns:**

```elixir
# ✅ Good: Pure, testable business logic
def confirm(%Order{status: :pending, items: [_|_]} = order) do
  {:ok, %{order | status: :confirmed}}
end

# ✅ Good: Reference aggregates by ID
%Order{customer_id: "cust_123"}

# ❌ Bad: Repository for non-root entity
OrderItemRepository  # Don't do this!
```

Would you like me to show:
- How to handle domain events between aggregates?
- Implementing CQRS patterns in Elixir?
- How to model complex aggregate relationships?
- GenServer-based aggregate persistence patterns?

## Core Concepts

### 1. Entities
Entities have identity and lifecycle. In Elixir, use structs with unique identifiers.

```elixir
# lib/my_app/domain/orders/order.ex
defmodule MyApp.Domain.Orders.Order do
  @moduledoc """
  Order Entity - Has identity (id) and lifecycle
  """
  
  alias MyApp.Domain.Orders.{OrderItem, OrderStatus, Money}
  
  @enforce_keys [:id, :customer_id]
  defstruct [
    :id,
    :customer_id,
    :status,
    items: [],
    total: %Money{amount: 0, currency: "USD"},
    created_at: nil,
    updated_at: nil
  ]
  
  @type t :: %__MODULE__{
    id: String.t(),
    customer_id: String.t(),
    status: OrderStatus.t(),
    items: [OrderItem.t()],
    total: Money.t(),
    created_at: DateTime.t() | nil,
    updated_at: DateTime.t() | nil
  }
  
  # Entity equality based on ID
  def equals?(%__MODULE__{id: id}, %__MODULE__{id: id}), do: true
  def equals?(_, _), do: false
end
```

### 2. Value Objects
Immutable objects defined by their attributes, no identity.

```elixir
# lib/my_app/domain/orders/money.ex
defmodule MyApp.Domain.Orders.Money do
  @moduledoc """
  Value Object - No identity, compared by value
  """
  
  @enforce_keys [:amount, :currency]
  defstruct [:amount, :currency]
  
  @type t :: %__MODULE__{
    amount: Decimal.t(),
    currency: String.t()
  }
  
  def new(amount, currency \\ "USD") do
    with {:ok, decimal} <- parse_amount(amount),
         :ok <- validate_currency(currency) do
      {:ok, %__MODULE__{amount: decimal, currency: currency}}
    end
  end
  
  def add(%__MODULE__{currency: curr} = m1, %__MODULE__{currency: curr} = m2) do
    {:ok, %__MODULE__{
      amount: Decimal.add(m1.amount, m2.amount),
      currency: curr
    }}
  end
  
  def add(%__MODULE__{}, %__MODULE__{}), do: {:error, :currency_mismatch}
  
  defp parse_amount(amount) when is_binary(amount) do
    case Decimal.parse(amount) do
      {decimal, ""} -> {:ok, decimal}
      _ -> {:error, :invalid_amount}
    end
  end
  defp parse_amount(amount) when is_number(amount) do
    {:ok, Decimal.new(amount)}
  end
  
  defp validate_currency(curr) when curr in ~w(USD EUR GBP), do: :ok
  defp validate_currency(_), do: {:error, :invalid_currency}
end
```

### 3. Aggregates
Cluster of entities and value objects with a root entity that enforces invariants.

```elixir
# lib/my_app/domain/orders/order.ex (continued)
defmodule MyApp.Domain.Orders.Order do
  # ... (previous code)
  
  alias MyApp.Domain.Orders.{OrderItem, Money}
  
  # Constructor - enforces invariants at creation
  def new(attrs) do
    with :ok <- validate_customer_id(attrs.customer_id),
         {:ok, id} <- generate_id() do
      {:ok, %__MODULE__{
        id: id,
        customer_id: attrs.customer_id,
        status: :pending,
        items: [],
        total: Money.new(0),
        created_at: DateTime.utc_now()
      }}
    end
  end
  
  # Business logic - maintains invariants
  def add_item(%__MODULE__{status: :pending} = order, attrs) do
    with {:ok, item} <- OrderItem.new(attrs),
         :ok <- validate_item_limit(order.items) do
      items = [item | order.items]
      total = calculate_total(items)
      
      {:ok, %{order | items: items, total: total, updated_at: DateTime.utc_now()}}
    end
  end
  
  def add_item(%__MODULE__{}, _attrs) do
    {:error, :cannot_modify_non_pending_order}
  end
  
  def remove_item(%__MODULE__{status: :pending} = order, item_id) do
    case Enum.reject(order.items, &(&1.id == item_id)) do
      ^order.items -> {:error, :item_not_found}
      items ->
        total = calculate_total(items)
        {:ok, %{order | items: items, total: total, updated_at: DateTime.utc_now()}}
    end
  end
  
  def remove_item(%__MODULE__{}, _item_id) do
    {:error, :cannot_modify_non_pending_order}
  end
  
  def confirm(%__MODULE__{status: :pending, items: items} = order) 
      when length(items) > 0 do
    {:ok, %{order | status: :confirmed, updated_at: DateTime.utc_now()}}
  end
  
  def confirm(%__MODULE__{status: :pending, items: []}), do: {:error, :order_is_empty}
  def confirm(%__MODULE__{}), do: {:error, :order_already_confirmed}
  
  def cancel(%__MODULE__{status: status} = order) 
      when status in [:pending, :confirmed] do
    {:ok, %{order | status: :cancelled, updated_at: DateTime.utc_now()}}
  end
  
  def cancel(%__MODULE__{}), do: {:error, :cannot_cancel_order}
  
  # Private helpers
  defp validate_customer_id(id) when is_binary(id) and byte_size(id) > 0, do: :ok
  defp validate_customer_id(_), do: {:error, :invalid_customer_id}
  
  defp validate_item_limit(items) when length(items) < 100, do: :ok
  defp validate_item_limit(_), do: {:error, :max_items_exceeded}
  
  defp calculate_total(items) do
    Enum.reduce(items, Money.new(0), fn item, acc ->
      {:ok, total} = Money.add(acc, item.subtotal)
      total
    end)
  end
  
  defp generate_id, do: {:ok, Ecto.UUID.generate()}
end
```

```elixir
# lib/my_app/domain/orders/order_item.ex
defmodule MyApp.Domain.Orders.OrderItem do
  @moduledoc """
  Entity within the Order aggregate
  """
  
  alias MyApp.Domain.Orders.Money
  
  @enforce_keys [:id, :product_id, :quantity, :unit_price]
  defstruct [:id, :product_id, :quantity, :unit_price, :subtotal]
  
  @type t :: %__MODULE__{
    id: String.t(),
    product_id: String.t(),
    quantity: pos_integer(),
    unit_price: Money.t(),
    subtotal: Money.t()
  }
  
  def new(attrs) do
    with {:ok, id} <- generate_id(),
         :ok <- validate_quantity(attrs.quantity),
         {:ok, unit_price} <- Money.new(attrs.unit_price) do
      
      subtotal = calculate_subtotal(attrs.quantity, unit_price)
      
      {:ok, %__MODULE__{
        id: id,
        product_id: attrs.product_id,
        quantity: attrs.quantity,
        unit_price: unit_price,
        subtotal: subtotal
      }}
    end
  end
  
  def change_quantity(%__MODULE__{} = item, new_quantity) do
    with :ok <- validate_quantity(new_quantity) do
      subtotal = calculate_subtotal(new_quantity, item.unit_price)
      {:ok, %{item | quantity: new_quantity, subtotal: subtotal}}
    end
  end
  
  defp validate_quantity(qty) when is_integer(qty) and qty > 0 and qty <= 999, do: :ok
  defp validate_quantity(_), do: {:error, :invalid_quantity}
  
  defp calculate_subtotal(quantity, %Money{} = unit_price) do
    %Money{
      amount: Decimal.mult(unit_price.amount, Decimal.new(quantity)),
      currency: unit_price.currency
    }
  end
  
  defp generate_id, do: {:ok, Ecto.UUID.generate()}
end
```

### 4. Repository Interface (Port)
Define the contract using behaviours.

```elixir
# lib/my_app/interfaces/repositories/order_repository.ex
defmodule MyApp.Interfaces.Repositories.OrderRepository do
  @moduledoc """
  Repository interface for Order aggregate
  Only aggregate roots should have repositories
  """
  
  alias MyApp.Domain.Orders.Order
  
  @type order_id :: String.t()
  @type customer_id :: String.t()
  
  # Define the contract
  @callback save(Order.t()) :: {:ok, Order.t()} | {:error, term()}
  @callback find_by_id(order_id()) :: {:ok, Order.t()} | {:error, :not_found}
  @callback find_by_customer(customer_id()) :: {:ok, [Order.t()]} | {:error, term()}
  @callback delete(order_id()) :: :ok | {:error, term()}
  @callback exists?(order_id()) :: boolean()
  
  # Helper to get configured implementation
  def impl do
    Application.get_env(
      :my_app,
      :order_repository,
      MyApp.Infrastructure.Repositories.OrderRepository
    )
  end
end
```

### 5. Repository Implementation (Adapter)
Implement the repository with persistence logic.

```elixir
# lib/my_app/infrastructure/persistence/orders/order_schema.ex
defmodule MyApp.Infrastructure.Persistence.Orders.OrderSchema do
  @moduledoc """
  Ecto schema for persistence - separate from domain entity
  """
  use Ecto.Schema
  import Ecto.Changeset
  
  alias MyApp.Infrastructure.Persistence.Orders.OrderItemSchema
  
  @primary_key {:id, :binary_id, autogenerate: false}
  schema "orders" do
    field :customer_id, :string
    field :status, Ecto.Enum, values: [:pending, :confirmed, :shipped, :cancelled]
    field :total_amount, :decimal
    field :total_currency, :string
    
    has_many :items, OrderItemSchema, foreign_key: :order_id
    
    timestamps()
  end
  
  def changeset(schema, attrs) do
    schema
    |> cast(attrs, [:id, :customer_id, :status, :total_amount, :total_currency])
    |> validate_required([:id, :customer_id, :status, :total_amount, :total_currency])
    |> cast_assoc(:items)
  end
end
```

```elixir
# lib/my_app/infrastructure/repositories/order_repository.ex
defmodule MyApp.Infrastructure.Repositories.OrderRepository do
  @moduledoc """
  Concrete implementation of OrderRepository using Ecto
  """
  
  @behaviour MyApp.Interfaces.Repositories.OrderRepository
  
  import Ecto.Query
  
  alias MyApp.Domain.Orders.{Order, OrderItem, Money}
  alias MyApp.Infrastructure.Persistence.Repo
  alias MyApp.Infrastructure.Persistence.Orders.{OrderSchema, OrderItemSchema}
  
  @impl true
  def save(%Order{} = order) do
    # Map domain entity to schema
    schema_attrs = to_schema_attrs(order)
    
    changeset = OrderSchema.changeset(%OrderSchema{}, schema_attrs)
    
    case Repo.insert(changeset, on_conflict: :replace_all, conflict_target: :id) do
      {:ok, schema} -> 
        # Reload with associations and map back to domain
        schema = Repo.preload(schema, :items)
        {:ok, to_domain(schema)}
      {:error, changeset} -> 
        {:error, changeset}
    end
  end
  
  @impl true
  def find_by_id(id) do
    case Repo.get(OrderSchema, id) |> Repo.preload(:items) do
      nil -> {:error, :not_found}
      schema -> {:ok, to_domain(schema)}
    end
  end
  
  @impl true
  def find_by_customer(customer_id) do
    schemas =
      OrderSchema
      |> where([o], o.customer_id == ^customer_id)
      |> preload(:items)
      |> Repo.all()
    
    orders = Enum.map(schemas, &to_domain/1)
    {:ok, orders}
  end
  
  @impl true
  def delete(id) do
    case Repo.get(OrderSchema, id) do
      nil -> {:error, :not_found}
      schema -> 
        Repo.delete(schema)
        :ok
    end
  end
  
  @impl true
  def exists?(id) do
    Repo.exists?(from o in OrderSchema, where: o.id == ^id)
  end
  
  # Mapping functions
  defp to_schema_attrs(%Order{} = order) do
    %{
      id: order.id,
      customer_id: order.customer_id,
      status: order.status,
      total_amount: order.total.amount,
      total_currency: order.total.currency,
      inserted_at: order.created_at,
      updated_at: order.updated_at,
      items: Enum.map(order.items, &item_to_schema_attrs/1)
    }
  end
  
  defp item_to_schema_attrs(%OrderItem{} = item) do
    %{
      id: item.id,
      product_id: item.product_id,
      quantity: item.quantity,
      unit_price_amount: item.unit_price.amount,
      unit_price_currency: item.unit_price.currency,
      subtotal_amount: item.subtotal.amount,
      subtotal_currency: item.subtotal.currency
    }
  end
  
  defp to_domain(%OrderSchema{} = schema) do
    items = Enum.map(schema.items, &item_to_domain/1)
    
    %Order{
      id: schema.id,
      customer_id: schema.customer_id,
      status: schema.status,
      items: items,
      total: %Money{
        amount: schema.total_amount,
        currency: schema.total_currency
      },
      created_at: schema.inserted_at,
      updated_at: schema.updated_at
    }
  end
  
  defp item_to_domain(%OrderItemSchema{} = schema) do
    %OrderItem{
      id: schema.id,
      product_id: schema.product_id,
      quantity: schema.quantity,
      unit_price: %Money{
        amount: schema.unit_price_amount,
        currency: schema.unit_price_currency
      },
      subtotal: %Money{
        amount: schema.subtotal_amount,
        currency: schema.subtotal_currency
      }
    }
  end
end
```

### 6. Using Aggregates in Use Cases

```elixir
# lib/my_app/application/orders/create_order.ex
defmodule MyApp.Application.Orders.CreateOrder do
  @moduledoc """
  Use case: Create a new order
  Coordinates the order aggregate and repository
  """
  
  alias MyApp.Domain.Orders.Order
  alias MyApp.Interfaces.Repositories.OrderRepository
  
  def call(customer_id, items_attrs, deps \\ []) do
    order_repo = Keyword.get(deps, :order_repo, OrderRepository.impl())
    
    with {:ok, order} <- Order.new(%{customer_id: customer_id}),
         {:ok, order} <- add_items(order, items_attrs),
         {:ok, order} <- Order.confirm(order),
         {:ok, order} <- order_repo.save(order) do
      {:ok, order}
    end
  end
  
  defp add_items(order, items_attrs) do
    Enum.reduce_while(items_attrs, {:ok, order}, fn item_attrs, {:ok, acc_order} ->
      case Order.add_item(acc_order, item_attrs) do
        {:ok, updated_order} -> {:cont, {:ok, updated_order}}
        {:error, reason} -> {:halt, {:error, reason}}
      end
    end)
  end
end
```

```elixir
# lib/my_app/application/orders/update_order.ex
defmodule MyApp.Application.Orders.UpdateOrder do
  @moduledoc """
  Use case: Update an existing order
  """
  
  alias MyApp.Domain.Orders.Order
  alias MyApp.Interfaces.Repositories.OrderRepository
  
  def add_item(order_id, item_attrs, deps \\ []) do
    order_repo = Keyword.get(deps, :order_repo, OrderRepository.impl())
    
    with {:ok, order} <- order_repo.find_by_id(order_id),
         {:ok, order} <- Order.add_item(order, item_attrs),
         {:ok, order} <- order_repo.save(order) do
      {:ok, order}
    end
  end
  
  def remove_item(order_id, item_id, deps \\ []) do
    order_repo = Keyword.get(deps, :order_repo, OrderRepository.impl())
    
    with {:ok, order} <- order_repo.find_by_id(order_id),
         {:ok, order} <- Order.remove_item(order, item_id),
         {:ok, order} <- order_repo.save(order) do
      {:ok, order}
    end
  end
  
  def cancel(order_id, deps \\ []) do
    order_repo = Keyword.get(deps, :order_repo, OrderRepository.impl())
    
    with {:ok, order} <- order_repo.find_by_id(order_id),
         {:ok, order} <- Order.cancel(order),
         {:ok, order} <- order_repo.save(order) do
      {:ok, order}
    end
  end
end
```

## Key Principles

### Aggregate Rules

1. **Only Aggregate Roots have repositories** - Don't create repositories for entities within an aggregate
2. **Transactions boundary** - One aggregate = one transaction
3. **Reference by ID** - Aggregates reference other aggregates by ID only
4. **Invariants** - Aggregates enforce business invariants
5. **Consistency boundary** - Changes to aggregate must be atomic

### Example: Aggregate Boundaries

```elixir
# ❌ WRONG: OrderItem has its own repository
defmodule MyApp.Interfaces.Repositories.OrderItemRepository do
  # This breaks aggregate encapsulation
end

# ✅ CORRECT: Only Order (aggregate root) has repository
# OrderItems are always accessed through Order

# ❌ WRONG: Directly referencing another aggregate
defstruct [:id, :customer, :items]  # customer is full Customer struct

# ✅ CORRECT: Reference by ID
defstruct [:id, :customer_id, :items]  # just the ID

# If you need customer data, fetch it separately or use read models
```

### Testing Aggregates

```elixir
# test/my_app/domain/orders/order_test.exs
defmodule MyApp.Domain.Orders.OrderTest do
  use ExUnit.Case, async: true
  
  alias MyApp.Domain.Orders.{Order, Money}
  
  describe "new/1" do
    test "creates order with valid attributes" do
      assert {:ok, order} = Order.new(%{customer_id: "cust_123"})
      assert order.status == :pending
      assert order.items == []
      assert order.customer_id == "cust_123"
    end
    
    test "rejects invalid customer_id" do
      assert {:error, :invalid_customer_id} = Order.new(%{customer_id: ""})
    end
  end
  
  describe "add_item/2" do
    setup do
      {:ok, order} = Order.new(%{customer_id: "cust_123"})
      {:ok, order: order}
    end
    
    test "adds item to pending order", %{order: order} do
      item_attrs = %{product_id: "prod_1", quantity: 2, unit_price: "10.00"}
      
      assert {:ok, updated_order} = Order.add_item(order, item_attrs)
      assert length(updated_order.items) == 1
      assert updated_order.total.amount == Decimal.new("20.00")
    end
    
    test "rejects adding item to confirmed order", %{order: order} do
      item_attrs = %{product_id: "prod_1", quantity: 1, unit_price: "10.00"}
      {:ok, order} = Order.add_item(order, item_attrs)
      {:ok, order} = Order.confirm(order)
      
      assert {:error, :cannot_modify_non_pending_order} = 
        Order.add_item(order, item_attrs)
    end
  end
end
```

## Best Practices

1. **Keep aggregates small** - Large aggregates = performance problems
2. **Design around use cases** - What needs to be consistent together?
3. **Use domain events** - For communication between aggregates
4. **Separate read/write models** - Use projections for queries (CQRS)
5. **Make illegal states unrepresentable** - Use types and validation
6. **Pure functions** - All domain logic should be pure (testable!)
7. **Explicit state transitions** - Pattern match on current state