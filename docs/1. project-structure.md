# Phoenix Project Structure: Clean Architecture & DDD

I'll help you restructure a Phoenix Framework project to align with Clean Architecture and Domain-Driven Design (DDD) principles. This approach separates concerns and makes your codebase more maintainable and testable.I've created a comprehensive guide for restructuring your Phoenix project with Clean Architecture and DDD principles.

**Key highlights:**

1. **Domain Layer** - Pure business logic with no framework dependencies
2. **Application Layer** - Use cases that orchestrate domain objects
3. **Interfaces Layer** - Behaviours (ports) defining contracts
4. **Infrastructure Layer** - Implementations (adapters) for databases, external services
5. **Presentation Layer** - Thin controllers/LiveViews that delegate to use cases

**Important patterns:**
- Separate Ecto schemas from domain entities
- Use behaviours for dependency injection
- Keep domain logic framework-agnostic
- Map between domain entities and persistence schemas in repositories

Would you like me to elaborate on any specific part, such as:
- How to handle domain events?
- CQRS implementation in Phoenix?
- Testing strategies for this architecture?
- Migration path from a standard Phoenix structure?

## Proposed Folder Structure

```
lib/
├── my_app/                          # Core Application (Domain + Use Cases)
│   ├── domain/                      # Domain Layer (Entities, Value Objects)
│   │   ├── accounts/
│   │   │   ├── user.ex             # Entity
│   │   │   ├── email.ex            # Value Object
│   │   │   └── password.ex         # Value Object
│   │   ├── orders/
│   │   │   ├── order.ex
│   │   │   ├── order_item.ex
│   │   │   └── money.ex            # Value Object
│   │   └── shared/
│   │       └── aggregate_root.ex   # Shared domain behaviors
│   │
│   ├── application/                 # Application Layer (Use Cases)
│   │   ├── accounts/
│   │   │   ├── register_user.ex
│   │   │   ├── authenticate_user.ex
│   │   │   └── update_profile.ex
│   │   └── orders/
│   │       ├── create_order.ex
│   │       ├── cancel_order.ex
│   │       └── process_payment.ex
│   │
│   ├── infrastructure/              # Infrastructure Layer (Implementations)
│   │   ├── persistence/
│   │   │   ├── repo.ex             # Ecto Repo
│   │   │   ├── accounts/
│   │   │   │   └── user_schema.ex  # Ecto Schema (separate from domain)
│   │   │   └── orders/
│   │   │       └── order_schema.ex
│   │   ├── adapters/
│   │   │   ├── email_adapter.ex
│   │   │   ├── payment_gateway.ex
│   │   │   └── cache_adapter.ex
│   │   └── repositories/           # Repository Implementations
│   │       ├── user_repository.ex
│   │       └── order_repository.ex
│   │
│   └── interfaces/                  # Interface Layer (Ports/Contracts)
│       ├── repositories/
│       │   ├── user_repository.ex  # Behaviour (Protocol)
│       │   └── order_repository.ex
│       └── services/
│           ├── email_service.ex
│           └── payment_service.ex
│
├── my_app_web/                      # Presentation Layer
│   ├── controllers/
│   │   ├── user_controller.ex
│   │   └── order_controller.ex
│   ├── views/
│   ├── templates/
│   ├── live/                        # LiveView components
│   │   ├── user_live/
│   │   └── order_live/
│   ├── graphql/                     # If using GraphQL
│   │   ├── schema.ex
│   │   ├── resolvers/
│   │   └── types/
│   └── router.ex
│
└── my_app.ex                        # Application supervisor

test/
├── my_app/
│   ├── domain/
│   ├── application/
│   └── infrastructure/
└── my_app_web/
```

## Key Principles

### 1. **Domain Layer** (Core Business Logic)
- **Pure Elixir** - No dependencies on frameworks
- Contains entities, value objects, and domain events
- Business rules and domain logic only
- Example:

```elixir
# lib/my_app/domain/accounts/user.ex
defmodule MyApp.Domain.Accounts.User do
  @enforce_keys [:id, :email, :name]
  defstruct [:id, :email, :name, :created_at]

  alias MyApp.Domain.Accounts.Email

  def new(attrs) do
    with {:ok, email} <- Email.new(attrs.email) do
      {:ok, %__MODULE__{
        id: attrs.id,
        email: email,
        name: attrs.name,
        created_at: DateTime.utc_now()
      }}
    end
  end

  def change_email(%__MODULE__{} = user, new_email) do
    # Domain logic here
    with {:ok, email} <- Email.new(new_email) do
      {:ok, %{user | email: email}}
    end
  end
end
```

### 2. **Application Layer** (Use Cases)
- Orchestrates domain objects
- Depends on interfaces/ports (behaviours)
- Contains business workflows
- Example:

```elixir
# lib/my_app/application/accounts/register_user.ex
defmodule MyApp.Application.Accounts.RegisterUser do
  alias MyApp.Domain.Accounts.User
  alias MyApp.Interfaces.Repositories.UserRepository
  alias MyApp.Interfaces.Services.EmailService

  def call(attrs, deps \\ []) do
    user_repo = Keyword.get(deps, :user_repo, UserRepository.impl())
    email_service = Keyword.get(deps, :email_service, EmailService.impl())

    with {:ok, user} <- User.new(attrs),
         {:ok, user} <- user_repo.save(user),
         :ok <- email_service.send_welcome_email(user) do
      {:ok, user}
    end
  end
end
```

### 3. **Interfaces Layer** (Ports)
- Define contracts using behaviours
- Example:

```elixir
# lib/my_app/interfaces/repositories/user_repository.ex
defmodule MyApp.Interfaces.Repositories.UserRepository do
  alias MyApp.Domain.Accounts.User

  @callback save(User.t()) :: {:ok, User.t()} | {:error, term()}
  @callback find_by_id(String.t()) :: {:ok, User.t()} | {:error, :not_found}
  @callback find_by_email(String.t()) :: {:ok, User.t()} | {:error, :not_found}

  def impl do
    Application.get_env(:my_app, :user_repository, 
      MyApp.Infrastructure.Repositories.UserRepository)
  end
end
```

### 4. **Infrastructure Layer** (Adapters)
- Implements interfaces
- Contains Ecto schemas, external service adapters
- Example:

```elixir
# lib/my_app/infrastructure/repositories/user_repository.ex
defmodule MyApp.Infrastructure.Repositories.UserRepository do
  @behaviour MyApp.Interfaces.Repositories.UserRepository

  alias MyApp.Domain.Accounts.User
  alias MyApp.Infrastructure.Persistence.Accounts.UserSchema
  alias MyApp.Infrastructure.Persistence.Repo

  def save(%User{} = user) do
    changeset = UserSchema.changeset(%UserSchema{}, to_persistence(user))
    
    case Repo.insert(changeset) do
      {:ok, schema} -> {:ok, to_domain(schema)}
      {:error, changeset} -> {:error, changeset}
    end
  end

  defp to_domain(%UserSchema{} = schema) do
    User.new(%{
      id: schema.id,
      email: schema.email,
      name: schema.name
    })
  end

  defp to_persistence(%User{} = user) do
    %{
      id: user.id,
      email: user.email.value,
      name: user.name
    }
  end
end
```

### 5. **Presentation Layer** (Web)
- Controllers/LiveView are thin
- Delegate to application use cases
- Example:

```elixir
# lib/my_app_web/controllers/user_controller.ex
defmodule EngramAPIWeb.UserController do
  use EngramAPIWeb, :controller
  
  alias MyApp.Application.Accounts.RegisterUser

  def create(conn, %{"user" => user_params}) do
    case RegisterUser.call(user_params) do
      {:ok, user} ->
        conn
        |> put_status(:created)
        |> render("show.json", user: user)
      {:error, reason} ->
        conn
        |> put_status(:unprocessable_entity)
        |> render("error.json", error: reason)
    end
  end
end
```

## Configuration

```elixir
# config/config.exs
config :my_app,
  user_repository: MyApp.Infrastructure.Repositories.UserRepository,
  email_service: MyApp.Infrastructure.Adapters.EmailAdapter

# config/test.exs
config :my_app,
  user_repository: MyApp.Test.Mocks.UserRepository,
  email_service: MyApp.Test.Mocks.EmailService
```

## Benefits

1. **Testability**: Easy to mock dependencies via behaviours
2. **Maintainability**: Clear separation of concerns
3. **Independence**: Domain logic doesn't depend on frameworks
4. **Flexibility**: Easy to swap implementations (e.g., different databases)
5. **Team Scalability**: Teams can work on different bounded contexts independently

## Migration Strategy

1. Start with new features using this structure
2. Gradually refactor existing features by bounded context
3. Keep both structures running during transition
4. Move one aggregate at a time
5. Update tests alongside refactoring

## Common Patterns

- **Bounded Contexts**: Each context (accounts, orders, etc.) is self-contained
- **Aggregates**: Group related entities under one root
- **Value Objects**: Immutable objects defined by their attributes
- **Domain Events**: Communicate between bounded contexts
- **CQRS**: Separate read and write models if needed