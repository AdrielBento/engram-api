# CQRS in Elixir with Single Database


Great question! CQRS (Command Query Responsibility Segregation) with a single database is a practical approach. Let me show you how to implement it in Elixir/Phoenix:I've created a comprehensive guide for implementing CQRS in Elixir with a single database!

## Key Concepts:

**Commands (Write):**
- Represent intentions (`RegisterUser`, `UpdateProfile`)
- Validate business rules
- Write to normalized tables
- Update read models via projections

**Queries (Read):**
- Optimized for display (`GetUser`, `ListActiveUsers`)
- No business logic
- Read from denormalized tables
- Can use aggregations and joins freely

**Projections:**
- Sync read models after writes
- Keep denormalized data updated
- Can be synchronous (in transaction) or asynchronous (background jobs)

## Practical Benefits:

1. **Same Database** - No infrastructure complexity
2. **Fast Reads** - Denormalized data with pre-computed counts
3. **Clear Code** - Commands vs Queries are explicit
4. **Easy Testing** - Each side tested independently
5. **Future-Proof** - Easy to split to separate DBs later

The key difference from traditional CRUD:
- Traditional: `User.changeset()` for everything
- CQRS: `RegisterUser.execute()` (command) vs `GetUser.execute()` (query)

Would you like me to show:
- How to add async projections with Oban?
- Event sourcing with this setup?
- Testing strategies for commands vs queries?

## Overview

CQRS separates **Commands** (write operations) from **Queries** (read operations), even when using a single database. This provides:
- Optimized read models
- Clear separation of concerns
- Better scalability path
- Independent optimization of reads vs writes

## Folder Structure

```
lib/
├── my_app/
│   ├── domain/                      # Domain entities
│   │   └── accounts/
│   │       └── user.ex
│   │
│   ├── commands/                    # WRITE side (Commands)
│   │   └── accounts/
│   │       ├── register_user.ex
│   │       ├── update_profile.ex
│   │       └── deactivate_user.ex
│   │
│   ├── queries/                     # READ side (Queries)
│   │   └── accounts/
│   │       ├── get_user.ex
│   │       ├── list_active_users.ex
│   │       └── user_statistics.ex
│   │
│   ├── read_models/                 # Optimized for queries
│   │   └── accounts/
│   │       ├── user_summary.ex
│   │       └── user_statistics_view.ex
│   │
│   ├── write_models/                # Optimized for commands
│   │   └── accounts/
│   │       └── user_aggregate.ex
│   │
│   └── infrastructure/
│       ├── persistence/
│       │   ├── repo.ex
│       │   ├── write_schemas/      # Normalized schemas
│       │   │   └── user_schema.ex
│       │   └── read_schemas/       # Denormalized schemas
│       │       └── user_summary_schema.ex
│       └── projections/            # Update read models from writes
│           └── user_projection.ex
```

## Implementation

### 1. Commands (Write Side)

Commands represent **intentions** to change state. They validate business rules and persist changes.

```elixir
# lib/my_app/commands/accounts/register_user.ex
defmodule MyApp.Commands.Accounts.RegisterUser do
  @moduledoc """
  Command: Register a new user
  Handles write operations with full business logic validation
  """

  alias MyApp.Domain.Accounts.User
  alias MyApp.Infrastructure.Persistence.WriteSchemas.UserSchema
  alias MyApp.Infrastructure.Persistence.Repo
  alias MyApp.Infrastructure.Projections.UserProjection

  defstruct [:email, :name, :password]

  def execute(%__MODULE__{} = command) do
    Repo.transaction(fn ->
      with {:ok, user} <- validate_and_create(command),
           {:ok, persisted} <- persist_user(user),
           :ok <- UserProjection.project_user_created(persisted) do
        persisted
      else
        {:error, reason} -> Repo.rollback(reason)
      end
    end)
  end

  defp validate_and_create(command) do
    # Domain validation
    User.new(%{
      email: command.email,
      name: command.name,
      password: command.password
    })
  end

  defp persist_user(user) do
    %UserSchema{}
    |> UserSchema.registration_changeset(%{
      id: user.id,
      email: user.email.value,
      name: user.name,
      password_hash: user.password_hash,
      status: :active
    })
    |> Repo.insert()
  end
end
```

```elixir
# lib/my_app/commands/accounts/update_profile.ex
defmodule MyApp.Commands.Accounts.UpdateProfile do
  @moduledoc """
  Command: Update user profile
  """

  alias MyApp.Infrastructure.Persistence.WriteSchemas.UserSchema
  alias MyApp.Infrastructure.Persistence.Repo
  alias MyApp.Infrastructure.Projections.UserProjection

  defstruct [:user_id, :name, :bio]

  def execute(%__MODULE__{} = command) do
    Repo.transaction(fn ->
      with {:ok, user_schema} <- fetch_user(command.user_id),
           {:ok, updated} <- update_user(user_schema, command),
           :ok <- UserProjection.project_user_updated(updated) do
        updated
      else
        {:error, reason} -> Repo.rollback(reason)
      end
    end)
  end

  defp fetch_user(user_id) do
    case Repo.get(UserSchema, user_id) do
      nil -> {:error, :not_found}
      user -> {:ok, user}
    end
  end

  defp update_user(user_schema, command) do
    user_schema
    |> UserSchema.profile_changeset(%{
      name: command.name,
      bio: command.bio
    })
    |> Repo.update()
  end
end
```

### 2. Queries (Read Side)

Queries are **optimized for reading** and don't enforce business rules. They can use denormalized data.

```elixir
# lib/my_app/queries/accounts/get_user.ex
defmodule MyApp.Queries.Accounts.GetUser do
  @moduledoc """
  Query: Get user with all necessary display information
  Optimized for UI display
  """

  import Ecto.Query
  alias MyApp.Infrastructure.Persistence.Repo
  alias MyApp.Infrastructure.Persistence.ReadSchemas.UserSummarySchema
  alias MyApp.ReadModels.Accounts.UserSummary

  def execute(user_id) do
    UserSummarySchema
    |> where([u], u.id == ^user_id)
    |> Repo.one()
    |> case do
      nil -> {:error, :not_found}
      schema -> {:ok, to_read_model(schema)}
    end
  end

  defp to_read_model(schema) do
    %UserSummary{
      id: schema.id,
      email: schema.email,
      name: schema.name,
      bio: schema.bio,
      status: schema.status,
      created_at: schema.created_at,
      post_count: schema.post_count,
      follower_count: schema.follower_count
    }
  end
end
```

```elixir
# lib/my_app/queries/accounts/list_active_users.ex
defmodule MyApp.Queries.Accounts.ListActiveUsers do
  @moduledoc """
  Query: List all active users with pagination
  Optimized for listing views
  """

  import Ecto.Query
  alias MyApp.Infrastructure.Persistence.Repo
  alias MyApp.Infrastructure.Persistence.ReadSchemas.UserSummarySchema
  alias MyApp.ReadModels.Accounts.UserSummary

  defstruct page: 1, page_size: 20, search: nil

  def execute(%__MODULE__{} = params) do
    UserSummarySchema
    |> where([u], u.status == :active)
    |> maybe_search(params.search)
    |> order_by([u], desc: u.created_at)
    |> paginate(params.page, params.page_size)
    |> Repo.all()
    |> Enum.map(&to_read_model/1)
  end

  defp maybe_search(query, nil), do: query
  defp maybe_search(query, search) do
    search_term = "%#{search}%"
    where(query, [u], ilike(u.name, ^search_term) or ilike(u.email, ^search_term))
  end

  defp paginate(query, page, page_size) do
    offset = (page - 1) * page_size
    query
    |> limit(^page_size)
    |> offset(^offset)
  end

  defp to_read_model(schema) do
    %UserSummary{
      id: schema.id,
      email: schema.email,
      name: schema.name,
      status: schema.status,
      post_count: schema.post_count,
      follower_count: schema.follower_count
    }
  end
end
```

```elixir
# lib/my_app/queries/accounts/user_statistics.ex
defmodule MyApp.Queries.Accounts.UserStatistics do
  @moduledoc """
  Query: Get aggregated user statistics
  Complex query optimized for analytics
  """

  import Ecto.Query
  alias MyApp.Infrastructure.Persistence.Repo
  alias MyApp.Infrastructure.Persistence.ReadSchemas.UserSummarySchema

  def execute do
    query = from u in UserSummarySchema,
      select: %{
        total_users: count(u.id),
        active_users: filter(count(u.id), u.status == :active),
        inactive_users: filter(count(u.id), u.status == :inactive),
        avg_posts_per_user: avg(u.post_count),
        total_posts: sum(u.post_count)
      }

    Repo.one(query)
  end
end
```

### 3. Read Models (DTOs)

```elixir
# lib/my_app/read_models/accounts/user_summary.ex
defmodule MyApp.ReadModels.Accounts.UserSummary do
  @moduledoc """
  Read Model: Optimized view of user data for display
  This is NOT the domain entity - it's a projection
  """

  @enforce_keys [:id, :email, :name]
  defstruct [
    :id,
    :email,
    :name,
    :bio,
    :status,
    :created_at,
    :post_count,
    :follower_count,
    :following_count
  ]
end
```

### 4. Schemas

```elixir
# lib/my_app/infrastructure/persistence/write_schemas/user_schema.ex
defmodule MyApp.Infrastructure.Persistence.WriteSchemas.UserSchema do
  @moduledoc """
  Write Schema: Normalized structure for commands
  Contains only essential fields for writes
  """
  
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}
  
  schema "users" do
    field :email, :string
    field :name, :string
    field :bio, :string
    field :password_hash, :string
    field :status, Ecto.Enum, values: [:active, :inactive, :suspended]
    
    timestamps()
  end

  def registration_changeset(schema, attrs) do
    schema
    |> cast(attrs, [:id, :email, :name, :password_hash, :status])
    |> validate_required([:email, :name, :password_hash])
    |> unique_constraint(:email)
  end

  def profile_changeset(schema, attrs) do
    schema
    |> cast(attrs, [:name, :bio])
    |> validate_required([:name])
  end
end
```

```elixir
# lib/my_app/infrastructure/persistence/read_schemas/user_summary_schema.ex
defmodule MyApp.Infrastructure.Persistence.ReadSchemas.UserSummarySchema do
  @moduledoc """
  Read Schema: Denormalized structure for queries
  Contains aggregated data for fast reads
  """
  
  use Ecto.Schema

  @primary_key {:id, :binary_id, autogenerate: false}
  
  schema "user_summaries" do
    field :email, :string
    field :name, :string
    field :bio, :string
    field :status, Ecto.Enum, values: [:active, :inactive, :suspended]
    field :created_at, :utc_datetime
    
    # Denormalized counts for fast queries
    field :post_count, :integer, default: 0
    field :follower_count, :integer, default: 0
    field :following_count, :integer, default: 0
    
    # Computed fields
    field :last_activity_at, :utc_datetime
    
    timestamps(updated_at: :refreshed_at)
  end
end
```

### 5. Projections (Sync Read Models)

Projections update read models when write models change.

```elixir
# lib/my_app/infrastructure/projections/user_projection.ex
defmodule MyApp.Infrastructure.Projections.UserProjection do
  @moduledoc """
  Projection: Synchronizes read models from write operations
  Updates denormalized data in user_summaries table
  """

  alias MyApp.Infrastructure.Persistence.Repo
  alias MyApp.Infrastructure.Persistence.ReadSchemas.UserSummarySchema

  def project_user_created(user_schema) do
    %UserSummarySchema{
      id: user_schema.id,
      email: user_schema.email,
      name: user_schema.name,
      bio: user_schema.bio,
      status: user_schema.status,
      created_at: user_schema.inserted_at,
      post_count: 0,
      follower_count: 0,
      following_count: 0
    }
    |> Repo.insert()
    |> case do
      {:ok, _} -> :ok
      {:error, reason} -> {:error, reason}
    end
  end

  def project_user_updated(user_schema) do
    UserSummarySchema
    |> Repo.get(user_schema.id)
    |> case do
      nil -> {:error, :not_found}
      summary ->
        summary
        |> Ecto.Changeset.change(%{
          name: user_schema.name,
          bio: user_schema.bio,
          status: user_schema.status
        })
        |> Repo.update()
        |> case do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
    end
  end

  def increment_post_count(user_id) do
    UserSummarySchema
    |> Repo.get(user_id)
    |> case do
      nil -> {:error, :not_found}
      summary ->
        summary
        |> Ecto.Changeset.change(%{
          post_count: summary.post_count + 1,
          last_activity_at: DateTime.utc_now()
        })
        |> Repo.update()
        |> case do
          {:ok, _} -> :ok
          {:error, reason} -> {:error, reason}
        end
    end
  end
end
```

### 6. Controller Integration

```elixir
# lib/my_app_web/controllers/user_controller.ex
defmodule EngramAPIWeb.UserController do
  use EngramAPIWeb, :controller

  alias MyApp.Commands.Accounts.RegisterUser
  alias MyApp.Commands.Accounts.UpdateProfile
  alias MyApp.Queries.Accounts.GetUser
  alias MyApp.Queries.Accounts.ListActiveUsers

  # Command (Write)
  def create(conn, %{"user" => user_params}) do
    command = %RegisterUser{
      email: user_params["email"],
      name: user_params["name"],
      password: user_params["password"]
    }

    case RegisterUser.execute(command) do
      {:ok, user} ->
        conn
        |> put_status(:created)
        |> json(%{data: %{id: user.id}})
      {:error, reason} ->
        conn
        |> put_status(:unprocessable_entity)
        |> json(%{error: reason})
    end
  end

  # Command (Write)
  def update(conn, %{"id" => id, "user" => user_params}) do
    command = %UpdateProfile{
      user_id: id,
      name: user_params["name"],
      bio: user_params["bio"]
    }

    case UpdateProfile.execute(command) do
      {:ok, _user} ->
        json(conn, %{data: %{success: true}})
      {:error, reason} ->
        conn
        |> put_status(:unprocessable_entity)
        |> json(%{error: reason})
    end
  end

  # Query (Read)
  def show(conn, %{"id" => id}) do
    case GetUser.execute(id) do
      {:ok, user} ->
        json(conn, %{data: user})
      {:error, :not_found} ->
        conn
        |> put_status(:not_found)
        |> json(%{error: "User not found"})
    end
  end

  # Query (Read)
  def index(conn, params) do
    query = %ListActiveUsers{
      page: Map.get(params, "page", 1),
      page_size: Map.get(params, "page_size", 20),
      search: Map.get(params, "search")
    }

    users = ListActiveUsers.execute(query)
    json(conn, %{data: users})
  end
end
```

## Migrations

```elixir
# priv/repo/migrations/20240101000001_create_users.exs
defmodule MyApp.Repo.Migrations.CreateUsers do
  use Ecto.Migration

  def change do
    create table(:users, primary_key: false) do
      add :id, :binary_id, primary_key: true
      add :email, :string, null: false
      add :name, :string, null: false
      add :bio, :text
      add :password_hash, :string, null: false
      add :status, :string, null: false, default: "active"

      timestamps()
    end

    create unique_index(:users, [:email])
  end
end
```

```elixir
# priv/repo/migrations/20240101000002_create_user_summaries.exs
defmodule MyApp.Repo.Migrations.CreateUserSummaries do
  use Ecto.Migration

  def change do
    create table(:user_summaries, primary_key: false) do
      add :id, :binary_id, primary_key: true
      add :email, :string, null: false
      add :name, :string, null: false
      add :bio, :text
      add :status, :string, null: false
      add :created_at, :utc_datetime, null: false
      
      # Denormalized counts
      add :post_count, :integer, default: 0
      add :follower_count, :integer, default: 0
      add :following_count, :integer, default: 0
      
      add :last_activity_at, :utc_datetime

      timestamps(updated_at: :refreshed_at)
    end

    # Indexes for common queries
    create index(:user_summaries, [:status])
    create index(:user_summaries, [:created_at])
    create index(:user_summaries, [:name])
  end
end
```

## Benefits

1. **Clear Separation**: Commands change state, queries read state
2. **Optimized Queries**: Read models can be denormalized for performance
3. **Scalability**: Easy to move to separate databases later
4. **Testability**: Commands and queries tested independently
5. **Performance**: Queries don't lock write tables

## When to Use Projections

- **Synchronous** (in transaction): Simple counts, status changes
- **Asynchronous** (background jobs): Complex aggregations, heavy computations

## Evolution Path

1. **Start**: Single table for reads/writes
2. **Optimize**: Add denormalized columns to same table
3. **Separate**: Create read-only tables (user_summaries)
4. **Scale**: Move read tables to replica database
5. **Advanced**: Separate read/write databases with event sourcing