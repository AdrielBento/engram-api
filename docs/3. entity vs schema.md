# Phoenix Project Structure: Clean Architecture & DDD

## Proposed Folder Structure

```
lib/
├── my_app/                          # Core Application (Domain + Use Cases)
│   ├── domain/                      # Domain Layer (Entities, Value Objects)
│   │   ├── accounts/
│   │   │   ├── user.ex             # Entity
│   │   │   ├── email.ex            # Value Object
│   │   │   └── password.ex         # Value Object
│   │   ├── orders/
│   │   │   ├── order.ex
│   │   │   ├── order_item.ex
│   │   │   └── money.ex            # Value Object
│   │   └── shared/
│   │       └── aggregate_root.ex   # Shared domain behaviors
│   │
│   ├── application/                 # Application Layer (Use Cases)
│   │   ├── accounts/
│   │   │   ├── register_user.ex
│   │   │   ├── authenticate_user.ex
│   │   │   └── update_profile.ex
│   │   └── orders/
│   │       ├── create_order.ex
│   │       ├── cancel_order.ex
│   │       └── process_payment.ex
│   │
│   ├── infrastructure/              # Infrastructure Layer (Implementations)
│   │   ├── persistence/
│   │   │   ├── repo.ex             # Ecto Repo
│   │   │   ├── accounts/
│   │   │   │   └── user_schema.ex  # Ecto Schema (separate from domain)
│   │   │   └── orders/
│   │   │       └── order_schema.ex
│   │   ├── adapters/
│   │   │   ├── email_adapter.ex
│   │   │   ├── payment_gateway.ex
│   │   │   └── cache_adapter.ex
│   │   └── repositories/           # Repository Implementations
│   │       ├── user_repository.ex
│   │       └── order_repository.ex
│   │
│   └── interfaces/                  # Interface Layer (Ports/Contracts)
│       ├── repositories/
│       │   ├── user_repository.ex  # Behaviour (Protocol)
│       │   └── order_repository.ex
│       └── services/
│           ├── email_service.ex
│           └── payment_service.ex
│
├── my_app_web/                      # Presentation Layer
│   ├── controllers/
│   │   ├── user_controller.ex
│   │   └── order_controller.ex
│   ├── views/
│   ├── templates/
│   ├── live/                        # LiveView components
│   │   ├── user_live/
│   │   └── order_live/
│   ├── graphql/                     # If using GraphQL
│   │   ├── schema.ex
│   │   ├── resolvers/
│   │   └── types/
│   └── router.ex
│
└── my_app.ex                        # Application supervisor

test/
├── my_app/
│   ├── domain/
│   ├── application/
│   └── infrastructure/
└── my_app_web/
```

## Key Principles

### 1. **Domain Layer** (Core Business Logic)
- **Pure Elixir** - No dependencies on frameworks
- Contains entities, value objects, and domain events
- Business rules and domain logic only
- Example:

```elixir
# lib/my_app/domain/accounts/user.ex
defmodule MyApp.Domain.Accounts.User do
  @enforce_keys [:id, :email, :name]
  defstruct [:id, :email, :name, :created_at]

  alias MyApp.Domain.Accounts.Email

  def new(attrs) do
    with {:ok, email} <- Email.new(attrs.email) do
      {:ok, %__MODULE__{
        id: attrs.id,
        email: email,
        name: attrs.name,
        created_at: DateTime.utc_now()
      }}
    end
  end

  def change_email(%__MODULE__{} = user, new_email) do
    # Domain logic here
    with {:ok, email} <- Email.new(new_email) do
      {:ok, %{user | email: email}}
    end
  end
end
```

### 2. **Application Layer** (Use Cases)
- Orchestrates domain objects
- Depends on interfaces/ports (behaviours)
- Contains business workflows
- Example:

```elixir
# lib/my_app/application/accounts/register_user.ex
defmodule MyApp.Application.Accounts.RegisterUser do
  alias MyApp.Domain.Accounts.User
  alias MyApp.Interfaces.Repositories.UserRepository
  alias MyApp.Interfaces.Services.EmailService

  def call(attrs, deps \\ []) do
    user_repo = Keyword.get(deps, :user_repo, UserRepository.impl())
    email_service = Keyword.get(deps, :email_service, EmailService.impl())

    with {:ok, user} <- User.new(attrs),
         {:ok, user} <- user_repo.save(user),
         :ok <- email_service.send_welcome_email(user) do
      {:ok, user}
    end
  end
end
```

### 3. **Interfaces Layer** (Ports)
- Define contracts using behaviours
- Example:

```elixir
# lib/my_app/interfaces/repositories/user_repository.ex
defmodule MyApp.Interfaces.Repositories.UserRepository do
  alias MyApp.Domain.Accounts.User

  @callback save(User.t()) :: {:ok, User.t()} | {:error, term()}
  @callback find_by_id(String.t()) :: {:ok, User.t()} | {:error, :not_found}
  @callback find_by_email(String.t()) :: {:ok, User.t()} | {:error, :not_found}

  def impl do
    Application.get_env(:my_app, :user_repository, 
      MyApp.Infrastructure.Repositories.UserRepository)
  end
end
```

### 4. **Infrastructure Layer** (Adapters)
- Implements interfaces
- Contains Ecto schemas, external service adapters
- Example:

```elixir
# lib/my_app/infrastructure/repositories/user_repository.ex
defmodule MyApp.Infrastructure.Repositories.UserRepository do
  @behaviour MyApp.Interfaces.Repositories.UserRepository

  alias MyApp.Domain.Accounts.User
  alias MyApp.Infrastructure.Persistence.Accounts.UserSchema
  alias MyApp.Infrastructure.Persistence.Repo

  def save(%User{} = user) do
    changeset = UserSchema.changeset(%UserSchema{}, to_persistence(user))
    
    case Repo.insert(changeset) do
      {:ok, schema} -> {:ok, to_domain(schema)}
      {:error, changeset} -> {:error, changeset}
    end
  end

  defp to_domain(%UserSchema{} = schema) do
    User.new(%{
      id: schema.id,
      email: schema.email,
      name: schema.name
    })
  end

  defp to_persistence(%User{} = user) do
    %{
      id: user.id,
      email: user.email.value,
      name: user.name
    }
  end
end
```

## User.ex (Entity) vs UserSchema.ex - Detailed Comparison

### **Domain Entity** (`user.ex`)
**Purpose**: Represents business concepts and enforces business rules

```elixir
# lib/my_app/domain/accounts/user.ex
defmodule MyApp.Domain.Accounts.User do
  @moduledoc """
  Domain Entity - Represents a User in the business domain.
  Contains BUSINESS LOGIC and rules.
  """
  
  @enforce_keys [:id, :email, :name]
  defstruct [:id, :email, :name, :status, :role, :created_at, :last_login]

  alias MyApp.Domain.Accounts.Email

  # Business rules in constructors
  def new(attrs) do
    with {:ok, email} <- Email.new(attrs[:email]),
         :ok <- validate_name(attrs[:name]) do
      {:ok, %__MODULE__{
        id: attrs[:id] || generate_id(),
        email: email,
        name: attrs[:name],
        status: :pending,
        role: :user,
        created_at: DateTime.utc_now()
      }}
    end
  end

  # Business methods
  def activate(%__MODULE__{status: :pending} = user) do
    {:ok, %{user | status: :active}}
  end
  def activate(%__MODULE__{status: status}) do
    {:error, "Cannot activate user with status: #{status}"}
  end

  def promote_to_admin(%__MODULE__{role: :user} = user) do
    if meets_admin_requirements?(user) do
      {:ok, %{user | role: :admin}}
    else
      {:error, "User does not meet admin requirements"}
    end
  end

  def record_login(%__MODULE__{} = user) do
    %{user | last_login: DateTime.utc_now()}
  end

  # Business validation
  defp validate_name(name) when is_binary(name) and byte_size(name) >= 2 do
    :ok
  end
  defp validate_name(_), do: {:error, "Name must be at least 2 characters"}

  defp meets_admin_requirements?(%__MODULE__{created_at: created_at}) do
    # Business rule: User must be registered for at least 30 days
    days_registered = DateTime.diff(DateTime.utc_now(), created_at, :day)
    days_registered >= 30
  end

  defp generate_id, do: Ecto.UUID.generate()
end
```

### **Persistence Schema** (`user_schema.ex`)
**Purpose**: Maps to database table structure

```elixir
# lib/my_app/infrastructure/persistence/accounts/user_schema.ex
defmodule MyApp.Infrastructure.Persistence.Accounts.UserSchema do
  @moduledoc """
  Ecto Schema - Represents how User is STORED in the database.
  Contains DATABASE MAPPING and persistence concerns.
  """
  
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}
  @foreign_key_type :binary_id

  schema "users" do
    # Direct mapping to database columns
    field :email, :string
    field :name, :string
    field :status, Ecto.Enum, values: [:pending, :active, :suspended, :deleted]
    field :role, Ecto.Enum, values: [:user, :admin, :moderator]
    field :password_hash, :string
    field :last_login, :utc_datetime
    
    # Database-specific fields
    field :email_verified_at, :utc_datetime
    field :failed_login_attempts, :integer, default: 0
    field :locked_until, :utc_datetime
    
    timestamps(type: :utc_datetime)
  end

  # Database validation (NOT business rules)
  def changeset(schema, attrs) do
    schema
    |> cast(attrs, [:email, :name, :status, :role, :password_hash, :last_login])
    |> validate_required([:email, :name])
    |> validate_format(:email, ~r/@/)
    |> validate_length(:name, min: 2)
    |> unique_constraint(:email)
  end

  def registration_changeset(schema, attrs) do
    schema
    |> cast(attrs, [:email, :name, :password_hash])
    |> validate_required([:email, :name, :password_hash])
    |> validate_format(:email, ~r/@/)
    |> unique_constraint(:email)
  end
end
```

### **Key Differences**

| Aspect | Domain Entity (user.ex) | Persistence Schema (user_schema.ex) |
|--------|------------------------|-------------------------------------|
| **Purpose** | Business logic & rules | Database mapping |
| **Dependencies** | No framework dependencies | Depends on Ecto |
| **Fields** | Only what business needs | All database columns (including technical fields) |
| **Methods** | Business operations | Changesets for validation |
| **Validation** | Business rules | Data integrity/format |
| **Example Fields** | `email` (Value Object) | `email` (string), `email_verified_at`, `failed_login_attempts` |
| **Testing** | Pure Elixir, fast tests | Requires database setup |
| **Stability** | Changes with business rules | Changes with database schema |

### **Real Example: Email Field**

```elixir
# Domain Entity - Email is a Value Object
defmodule MyApp.Domain.Accounts.Email do
  @enforce_keys [:value]
  defstruct [:value]

  def new(value) when is_binary(value) do
    if valid_email?(value) do
      {:ok, %__MODULE__{value: String.downcase(value)}}
    else
      {:error, "Invalid email format"}
    end
  end

  defp valid_email?(email) do
    # Business rule: specific format required
    Regex.match?(~r/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$/, email)
  end
end

# In User entity:
# email: %Email{value: "user@example.com"}

# In UserSchema:
# email: "user@example.com" (just a string)
```

### **Why Separate Them?**

1. **Independent Evolution**: Database schema can change without affecting business logic
2. **Testability**: Domain entities don't need database for tests
3. **Flexibility**: Can store same entity in different databases differently
4. **Clean Dependencies**: Domain doesn't depend on infrastructure
5. **Business Focus**: Entity code reads like business requirements

### **Mapping Between Them**

```elixir
# In Repository
defp to_domain(%UserSchema{} = schema) do
  # Schema -> Entity
  with {:ok, email} <- Email.new(schema.email) do
    User.new(%{
      id: schema.id,
      email: email,
      name: schema.name,
      status: schema.status,
      role: schema.role,
      created_at: schema.inserted_at,
      last_login: schema.last_login
    })
  end
end

defp to_persistence(%User{} = user) do
  # Entity -> Schema
  %{
    id: user.id,
    email: user.email.value,  # Extract string from Value Object
    name: user.name,
    status: user.status,
    role: user.role,
    last_login: user.last_login
  }
end
```

### 5. **Presentation Layer** (Web)
- Controllers/LiveView are thin
- Delegate to application use cases
- Example:

```elixir
# lib/my_app_web/controllers/user_controller.ex
defmodule EngramAPIWeb.UserController do
  use EngramAPIWeb, :controller
  
  alias MyApp.Application.Accounts.RegisterUser

  def create(conn, %{"user" => user_params}) do
    case RegisterUser.call(user_params) do
      {:ok, user} ->
        conn
        |> put_status(:created)
        |> render("show.json", user: user)
      {:error, reason} ->
        conn
        |> put_status(:unprocessable_entity)
        |> render("error.json", error: reason)
    end
  end
end
```

## Configuration

```elixir
# config/config.exs
config :my_app,
  user_repository: MyApp.Infrastructure.Repositories.UserRepository,
  email_service: MyApp.Infrastructure.Adapters.EmailAdapter

# config/test.exs
config :my_app,
  user_repository: MyApp.Test.Mocks.UserRepository,
  email_service: MyApp.Test.Mocks.EmailService
```

## Benefits

1. **Testability**: Easy to mock dependencies via behaviours
2. **Maintainability**: Clear separation of concerns
3. **Independence**: Domain logic doesn't depend on frameworks
4. **Flexibility**: Easy to swap implementations (e.g., different databases)
5. **Team Scalability**: Teams can work on different bounded contexts independently

## Migration Strategy

1. Start with new features using this structure
2. Gradually refactor existing features by bounded context
3. Keep both structures running during transition
4. Move one aggregate at a time
5. Update tests alongside refactoring

## Common Patterns

- **Bounded Contexts**: Each context (accounts, orders, etc.) is self-contained
- **Aggregates**: Group related entities under one root
- **Value Objects**: Immutable objects defined by their attributes
- **Domain Events**: Communicate between bounded contexts
- **CQRS**: Separate read and write models if needed